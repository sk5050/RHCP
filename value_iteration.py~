#!/usr/bin/env python

import sys
import time
from utils import *
from graph import Node, Graph


class LAOStar(object):

    def __init__(self, model, constrained=False, method='VI', VI_epsilon=1e-50, VI_max_iter=100000, convergence_epsilon=1e-50, \
                 bounds=[], alpha=[], Lagrangian=False):

        self.model = model
        self.constrained = constrained
        self.method = method
        self.VI_epsilon = VI_epsilon
        self.VI_max_iter = VI_max_iter
        self.convergence_epsilon = convergence_epsilon
        
        self.bounds = bounds
        self.alpha = alpha
        self.Lagrangian=Lagrangian
        
        self.graph = Graph(name='G')
        self.graph.add_root(model.init_state, value=self.model.heuristic(model.init_state))

        self.fringe = {self.graph.root}


        self.debug_k = 0




    def compute_value(self,node,action):

        cost_vector = self.model.cost(node.state,action)

        value = cost_vector

        for child, child_prob in node.children[action]:

            value = ptw_add(value, scalar_mul(child.value,child_prob))

        return value





    def value_iteration(self, Z, epsilon=1e-50, max_iter=100000,return_on_policy_change=False):

        # if self.debug_k==15:
        #     for z in Z:
        #         print(z.state)
        #     print(len(Z))

        iter=0

        V_prev = dict()
        V_new = dict()
        for node in Z:
            if node.terminal==False:
                V_prev[node.state] = node.value
                V_new[node.state] = [float('inf')]*(len(self.bounds)+1)


        while not self.VI_convergence_test(V_prev,V_new,epsilon):
            for node in Z:
                if node.terminal==False:
                    V_prev[node.state] = node.value

                    actions = self.model.actions(node.state)
                    min_value = [float('inf')]*(len(self.bounds)+1)
                    weighted_min_value = float('inf')

                    prev_best_action = node.best_action
                    best_action = None

                    for action in actions:

                        new_value = self.compute_value(node,action)

                        if self.constrained==False:  # simple SSP case
                            if new_value[0] < min_value[0]:
                                min_value = new_value
                                best_action = action

                        else:
                            if self.Lagrangian==False:
                                raise ValueError("need to be implemented for constrained case.")
                            else:
                                weighted_value = self.compute_weighted_value(new_value)

                                if weighted_value < weighted_min_value:
                                    min_value = new_value
                                    weighted_min_value = weighted_value
                                    best_action = action

                    V_new[node.state] = min_value
                    if return_on_policy_change==True:
                        if prev_best_action != best_action:
                            return False

            for node in Z:
                if node.terminal==False:
                    node.value = V_new[node.state]

            iter += 1
                    
            if iter > max_iter:
                print("Maximun number of iteration reached.")
                break

        return V_new



    def VI_convergence_test(self,V_prev,V_new,epsilon):
        # might need more fast implementation. Numpy is better, but I am considering using pypy

        if self.constrained==False:
            error = max([abs(V_prev[state][0]-V_new.get(state,0)[0]) for state in V_prev])
        else:
            diff = []
            for state in V_prev:
               
                weighted_V_prev = self.compute_weighted_value(V_prev[state])
                weighted_V_new = self.compute_weighted_value(V_new[state])
                diff.append(abs(weighted_V_prev - weighted_V_new))


            error = max(diff)

        
        if error < epsilon:
            return True
        else:
            return False
