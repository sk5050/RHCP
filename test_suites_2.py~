#!/usr/bin/env python

import sys
from utils import import_models
import_models()

from graph import Node, Graph
from LAOStar import LAOStar
from CSSPSolver import CSSPSolver
from grid_model import GRIDModel
from grid_model_multiple_bounds import GRIDModel_multiple_bounds
from racetrack_model import RaceTrackModel
from LAO_paper_model import LAOModel

from grid import Grid
# import functools

from matplotlib.collections import LineCollection, PolyCollection
from matplotlib.patches import Ellipse

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import time


def linspace(start, stop, n):
    if n == 1:
        yield stop
        return
    h = (stop - start) / (n - 1)
    for i in range(n):
        yield start + h * i



def test_LAOStar():

    init_state = (0,0)
    size = (5,5)
    goal = (4,4)
    model = GRIDModel(size, init_state, goal, prob_right_transition=0.85)

    alpha = [0.0]
    bounds = [1.5]


    
    algo = LAOStar(model,constrained=True,VI_epsilon=1e-1, convergence_epsilon=1e-3,\
                   bounds=bounds,alpha=alpha,Lagrangian=True)
    

    t = time.time()
    policy = algo.solve()
    print("elapsed time: "+str(time.time()-t))
    print("number of states explored: "+str(len(algo.graph.nodes)))
    
    value_1 = algo.graph.root.value_1
    # weighted_value = value[0] + alpha[0]*(value[1] - bounds[0]) + alpha[1]*(value[2] - bounds[1])
    value_2 = algo.graph.root.value_2
    print(value_1)
    print(value_2)
    # print(weighted_value)




def test_LAOStar_racetrack():

    map_file = "models/racetrack_simple_3.txt"
    init_state = (1,1,0,0)
    model = RaceTrackModel(map_file, init_state = init_state,slip_prob=0.1)

    # init_state = (0,0)
    # size = (5,5)
    # goal = (4,4)
    # model = GRIDModel(size, init_state, goal, prob_right_transition=0.85)

    alpha = [0.0]
    bounds = [1.5]


    
    algo = LAOStar(model,constrained=True,VI_epsilon=1e-1, convergence_epsilon=1e-3,\
                   bounds=bounds,alpha=alpha,Lagrangian=True)
    

    t = time.time()
    policy = algo.solve()
    print("elapsed time: "+str(time.time()-t))
    print("number of states explored: "+str(len(algo.graph.nodes)))
    
    value_1 = algo.graph.root.value_1
    # weighted_value = value[0] + alpha[0]*(value[1] - bounds[0]) + alpha[1]*(value[2] - bounds[1])
    value_2 = algo.graph.root.value_2
    print(value_1)
    print(value_2)
    # print(weighted_value)




    map_text = open(map_file, 'r')
    lines = map_text.readlines()

    test_grid = Grid(len(lines[0]),len(lines))
    axes = test_grid.draw()

    offtrack = []
    for i in range(len(lines)):
        for j in range(len(lines[0])):
            offtrack.append((j,i))

    for pos in model.ontrack_pos_set:
        offtrack.remove(pos)

    for pos in model.finishline_pos_set:
        offtrack.remove(pos)


    initial = [test_grid.cell_verts(ix, iy) for ix,iy in model.initial_pos_set]
    collection_initial = PolyCollection(initial, facecolors='g')
    axes.add_collection(collection_initial)

    finish = [test_grid.cell_verts(ix, iy) for ix,iy in model.finishline_pos_set]
    collection_finish = PolyCollection(finish, facecolors='b')
    axes.add_collection(collection_finish)

    off = [test_grid.cell_verts(ix, iy) for ix,iy in offtrack]
    collection_off = PolyCollection(off, facecolors='r')
    axes.add_collection(collection_off)    


    # for init_pos in racetrack_model.initial_pos_set:

    #     if init_pos+(0,0) in 
        

    for state,action in policy.items():
        if action=='Terminal':
            continue
        
        new_states = model.state_transitions(state,action)

        if new_states[0][0][0:2]!=(-1,-1):
            path1 = [state[0:2], new_states[0][0][0:2]]
            test_grid.draw_path(axes, path1, color='y')

        if new_states[1][0][0:2]!=(-1,-1):
            path2 = [state[0:2], new_states[1][0][0:2]]
            test_grid.draw_path(axes, path2, color='y')

    plt.show()

        

    


def test_LAOStar_multiple_bounds():

    init_state = (0,0)
    size = (5,5)
    goal = (4,4)
    model = GRIDModel_multiple_bounds(size, init_state, goal, prob_right_transition=0.85)



    alpha = [0.2, 0.1]
    bounds = [1.5, -0.7]


    algo = LAOStar(model,constrained=True,bounds=bounds,alpha=alpha,Lagrangian=True)

    policy = algo.solve()

    value = algo.graph.root.value
    weighted_value = value[0] + alpha[0]*(value[1] - bounds[0]) + alpha[1]*(value[2] - bounds[1])

    print(value[0])
    print(value[1])
    print(weighted_value)

def draw_lower_envelop():

    init_state = (0,0)
    size = (5,5)
    goal = (4,4)
    model = GRIDModel(size, init_state, goal, prob_right_transition=0.85)

    # model = LAOModel()

    # algo = LAOStar(model)

    alpha_list = list(linspace(0,0.6,100))

    # alpha_list = [200]
    weighted_value_list = []

    bound = 1.5

    for a in alpha_list:

        print(a)

        algo = LAOStar(model,constrained=True,bounds=[bound],alpha=[a],Lagrangian=True)

        policy = algo.solve()

        value = algo.graph.root.value
        weighted_value = value[0] + a*(value[1] - bound)
        weighted_value_list.append(weighted_value)

        model.print_policy(policy)


    # print(algo.compute_value(algo.graph.nodes[(4,2)],'D'))
    # print(algo.compute_value(algo.graph.nodes[(4,2)],'U'))
    # print(algo.compute_value(algo.graph.nodes[(4,2)],'R'))
    # print(algo.compute_value(algo.graph.nodes[(4,2)],'L'))


        
    # print(alpha_list)
    # print(weighted_value_list)

    print(alpha_list)
    print(weighted_value_list)
        
    plt.plot(alpha_list, weighted_value_list,'*')
    # plt.plot(0.05775379446627887, 9.357673380261254, 'r*') # with bound = 2
    # plt.plot(0.013834705882, 9.3420861953, 'r*')  # with bound = 3
    plt.plot(0.15374170009084218, 9.42260840432311, 'r*')  # with bound = 1.5


    plt.show()




def draw_lower_envelop_multiple_bounds():

    ## this is for two separate constraints

    init_state = (0,0)
    size = (5,5)
    goal = (4,4)
    model = GRIDModel_multiple_bounds(size, init_state, goal, prob_right_transition=0.85)

    # model = LAOModel()

    # algo = LAOStar(model)

    alpha_1_range = list(linspace(0.0,100,20))
    alpha_2_range = list(linspace(0.0,20,20))
    # alpha_1_range = [46.355221667242965]
    # alpha_2_range = [4.325548069037225]

    # alpha_2_range = [20]

    alpha_1_list = []
    alpha_2_list = []
    weighted_value_list = []

    # bounds = [0.5, -0.2]
    bounds = [1.5, 10]

    for a_1 in alpha_1_range:
        for a_2 in alpha_2_range:
            print([a_1, a_2])

            alpha_1_list.append(a_1)
            alpha_2_list.append(a_2)

            algo = LAOStar(model,constrained=True,bounds=bounds,alpha=[a_1, a_2],Lagrangian=True)

            policy = algo.solve()

            while policy == False:
                algo = LAOStar(model,constrained=True,bounds=bounds,alpha=[a_1, a_2],Lagrangian=True)
                policy = algo.solve()


            value = algo.graph.root.value
            weighted_value = value[0] + a_1*(value[1] - bounds[0]) + a_2*(value[2] - bounds[1])
            weighted_value_list.append(weighted_value)


    print(alpha_1_list)
    print(alpha_2_list)
    print(weighted_value_list)
            
    fig = plt.figure()
    ax = Axes3D(fig)
    
    plt.plot(alpha_1_list,alpha_2_list, weighted_value_list,'*')
    # plt.plot(0.15374170009084218, 9.42260840432311, 'r*')  # with bound = 1.5

    plt.show()
    





def draw_lower_envelop_multiple_bounds_lb_ub():

    ## this is for two separate constraints

    init_state = (0,0)
    size = (5,5)
    goal = (4,4)
    model = GRIDModel_multiple_bounds(size, init_state, goal, prob_right_transition=0.85)

    # model = LAOModel()

    # algo = LAOStar(model)

    alpha_1_range = list(linspace(0.01,1.0,15))
    alpha_2_range = list(linspace(0.01,0.3,15))
    # alpha_2_range = [20]

    alpha_1_list = []
    alpha_2_list = []
    weighted_value_list = []

    # bounds = [0.5, -0.2]
    bounds = [1.5, -0.9]

    for a_1 in alpha_1_range:
        for a_2 in alpha_2_range:
            print([a_1, a_2])

            alpha_1_list.append(a_1)
            alpha_2_list.append(a_2)

            algo = LAOStar(model,constrained=True,bounds=bounds,alpha=[a_1, a_2],Lagrangian=True)

            policy = algo.solve()

            # while policy == False:
            #     algo = LAOStar(model,constrained=True,bounds=bounds,alpha=[a_1, a_2],Lagrangian=True)
            #     policy = algo.solve()

            if policy == None:
                weighted_value = -200
                weighted_value_list.append(weighted_value)
                print("seems unbounded below")

            else:
                
                value = algo.graph.root.value
                weighted_value = value[0] + a_1*(value[1] - bounds[0]) + a_2*(value[2] - bounds[1])
                weighted_value_list.append(weighted_value)



    # min_val = 100000000
    # max_val = -10000000
    # for v in weighted_value_list:
    #     if v==-200:
    #         continue
    #     if v < min_val:
    #         min_val = v
    #     if v > max_val:
    #         max_val = v

    # diff = max_val - min_val

    # for i in range(len(weighted_value_list)):
    #     if weighted_value_list[i]<0:
    #         weighted_value_list[i] = 8.2
            

    print(alpha_1_list)
    print(alpha_2_list)
    print(weighted_value_list)
            
    fig = plt.figure()
    ax = Axes3D(fig)
    
    plt.plot(alpha_1_list,alpha_2_list, weighted_value_list,'*')
    # plt.plot(0.15374170009084218, 9.42260840432311, 'r*')  # with bound = 1.5
    ax.axes.set_zlim3d(bottom=9.0, top=9.4) 

    plt.show()




    


def test_dual_alg():
    init_state = (0,0)
    size = (5,5)
    goal = (4,4)
    model = GRIDModel(size, init_state, goal, prob_right_transition=0.85)

    bound = 1.5

    cssp_solver = CSSPSolver(model, bounds=[bound],VI_epsilon=1e-1,convergence_epsilon=1e-10)

    cssp_solver.solve([[0,0.6]])

    policy = cssp_solver.algo.extract_policy()

    model.print_policy(policy)



def test_dual_alg_multiple_bounds():
    init_state = (0,0)
    size = (5,5)
    goal = (4,4)
    model = GRIDModel_multiple_bounds(size, init_state, goal, prob_right_transition=0.85)
    

    bounds = [1.5, 12]

    cssp_solver = CSSPSolver(model, bounds=bounds)

    cssp_solver.solve([[0,100],[0,20]])

    policy = cssp_solver.algo.extract_policy()

    model.print_policy(policy)

    
    


# draw_lower_envelop()
# test_dual_alg()
# test_dual_alg_multiple_bounds()
# test_LAOStar()
test_LAOStar_racetrack()
# draw_lower_envelop_multiple_bounds()
# draw_lower_envelop_multiple_bounds_lb_ub()




